# 第2章 间距



在本章中，我们着眼于改变行和单词间距的各种单行Perl代码，将文件中的文本修改成的双倍行距和三倍行距，删除空行和双倍单词间距之类的任务。您还将了解各种命令行参数，例如**-p**，**-e**，**-n**和特殊变量（例如**$_** 和 "$\）。



## 2.1 将文件修改成双倍行距

```perl
perl -pe '$\ = "\n"' file
```

这行代码将文件变成双倍行距。我需要在这里解释三件事：**-p**和**-e**命令行选项以及简短的$\="\n" Perl程序。

使用**-e**选项可直接在命令行中输入Perl程序。 通常，您不想为每个小程序创建源文件。 使用*-e，您可以轻松地在命令行中直接编写一个程序。 在这种情况下，此单行代码中包含的整个Perl程序为$\="\n"。

确保在程序周围使用单引号（'）否则您的shell会将$\之类的内容解释为无价值的shell变量，从而有效地将其删除！

现在，让我们看一下**-p**开关。 指定**-p**告诉Perl在您的程序周围假设以下循环：

```perl
while(<>){
	# 程序（由-e指定）
}continue{
	print or die "-p failed: $!\n";
}
```

一般来说，这个程序将循环所有输入，执行代码，并打印**$_**的值，这使您可以快速修改输入的全部或部分行。**$_**变量是一个特殊变量，将替换为当前文本行。 也可以用其他东西代替。 在阅读本书时，您将学到有关$_的所有知识。

但是，更详细地了解此循环中发生的事情很重要。 首先，**while(<>)**循环从标准输入中获取每一行，并将其放入**$_**变量中。 接下来，执行**-e**指定的代码，然后执行**print**或**die**语句。

**continue**语句在每行之后执行**print**或**die**语句，这将尝试打印**$_**变量的内容。 如果尝试失败（例如，终端不可写或标准输出已重定向到不可写的内容），**die**将使Perl退出并显示一条错误消息。

在这种单行代码中，-e指定的代码为$\ ="\n"，因此Perl执行的程序如下所示：

```perl
while(<>){
	$\ = "\n";
}continue{
	print or die "-p failed: $!\n";
}
```

该Perl程序将每一行读入\$_变量，然后将​\$\设置为换行符并调用print。 另一个特殊变量是$\, 它与Awk中的ORS(输出记录分隔符)变量相似，因为它在每次打印操作后都会附加。 不带参数的print语句将打印\$_的内容，并将\$\附加在输出的末尾。

如此一来，每行打印时都保持不变，然后是\$\，后者被设置为换行符。 输入现在是双倍行距。实际上，不需要为每行都将$ \设置为换行符。 您可以在程序开始时将其设置一次：

```perl
perl -pe 'BEGIN {$\ = "\n"}' file
```

Perl在执行任何操作之前，在BEGIN代码块中将$\设置为换行符。BEGIN块是一个特殊的代码块，在Perl程序中的所有其他块之前先执行。 以下扩展后的Perl程序的工作方式与以前的单行程序完全相同：

```perl
BEGIN {$\ = "\n"}
while(<>){
}continue{
	print or die "-p failed: $!\n";
}
```

这是对文件修改成双倍间距的另一种方法。 该程序在每行的末尾附加另一个换行符，然后打印该行：

```perl
perl -pe '$_ .="\n"' file
```

这个单行程序相当于：

```perl
while(<>){
	$_ .="\n";
}continue{
	print or die "-p failed: $!\n";
}
```

写成\$ _ =\$ _. "\n"与写成\$ _ .="\n"相同。 该表达式仅将$ _与"\n"连接在一起。

但是，对文件进行双倍行距的最干净的方法可能是使用替换运算符**s**：

```perl
perl -pe 's/$/\n/' file
```

这种单行替换了匹配末尾的正则表达式$带有换行符的行，有效地在末尾添加换行符。

如果您运行的是Perl 5.10或更高版本，则可以使用say操作符。 say运算符的行为与print十分相似，但始终在行末添加换行符。 在Perl 5.10中，可以这样写同一行：

```perl
perl -nE 'say' file
```

-E命令行参数的工作方式与-e命令行参数的工作方式完全相同，但是它还启用了Perl 5.10功能，其中包括say运算符。 -n参数与-p相似，但是必须自己打印该行。

在这些最初的几个示例中，我将文件名作为单行程序传递的最后一个参数。 这样做时，单线程序操作该文件的内容。 如果没有将文件名传递给单行程序，它们将对来自标准输入的数据进行操作。从现在开始，我将不会在单行程序结尾处指定文件，但是如果您要在文件上运行单行程序，则可以随时将其添加回去。 编写单行代码时，最好直接在标准输入中输入内容，以快速测试它们是否正确。 然后，当确定单行程序正常工作时，可以在末尾传递一个或多个文件名。

同样，不要忘记Perl方便的文档系统**perldoc**。 只需在命令行中键入**perldoc perlrun**即可显示有关如何运行Perl以及所有命令行参数的信息。

## 2.2 除空白行外，将文件修改成双倍行距

```perl
perl -pe '$_ .="\n" unless /^$/'
```

通过在每个非空白行的末尾添加换行符，此单行代码会将所有不完全为空的行加倍间隔。 **unless**表示“如果不是，**unless /^$/**表示“如果不是从头到尾”，即空行。条件“从头到尾”仅对空白行有效。

这是一个更好程序，它考虑了一行中的空格和制表符：

```perl
perl -pe '$_ .="\n" if /\S/'
```

这里使用正则表达式/\S/, \S是\s的反面，即任意的非空字符。\s表示空字符，包括制表符，垂直制表符，空格，换行符和回车符。结果是具有至少一个非空白字符的每一行都修改成双倍行距。

## 2.3 三倍行距

可以通过在每行末尾输出更多换行符来简单地对文件进行三倍间隔：

```perl
perl -pe '$\ = "\n\n"'
```

或者：

```perl
perl -pe '$_ .="\n\n"'
```

或者：

```perl
perl -pe 's/$/\n\n/'
```

## 2.4 N倍行距

```perl
perl -pe '$_ .= "\n"x7'
```

这个单行程序在每行之后插入七个换行符。 请注意，我是如何使用"\n" x 7重复换行符七次的。 x运算符在左侧重复该值N次。

例如：

```perl
perl -e 'print "foo"x5'
```

打印foofoofoofoofoo。

附带说明一下，有时当您需要生成一定数量的数据时，x运算符非常有用。 例如，要生成1KB的数据，可以执行以下操作：

```perl
perl -e 'print "a"x1024'
```

将打印字符'a'1024次。

## 2.5 在每行之前添加空白行

```perl
perl -pe 's/^/\n/'
```

这种单行使用**s/regex/replace/**运算符。替换匹配的内容， 在个单行代码中，运算符为**s /^/\n/**，正则表达式为**^**，替换为**\n**。 ^模式与文本的开始位置匹配，运算符用换行符\ n代替，因此换行符插入到该行之前。

## 2.6 删除所有空白行

```perl
perl -ne 'print unless /^$/'
```

这个单行代码使用**-n**标志，该标志告诉Perl在程序周围假设一个不同于**-p**的循环：

```perl
while(<>){
	# code
}
```

将这个循环与之前指定**-p**时Perl假定的循环进行比较，会发现该循环没有**continue{print or die}**部分。 在此循环中，钻石运算符**<>**读取每行并将其放置在特殊变量$_中，但未打印出来！ 必须自己打印该行。当你需要有选择性的打印的时候，该功能非常有用。

在这个单行程序中，代码部分是**print unless /^$/**，因此整个的Perl程序变成：

```perl
while(<>){
	print unless /^$/;
}
```

进一步阐明这一点，您会得到：

```perl
while(<>){
	print $_ unless $_=~ /^$/;
}
```

以上的单行Perl程序打印所有非空白行。

以下的单行Perl程序也删除所有空白行：

```perl
perl -lne 'print if length'
```

这个单行代码使用**-l**命令行参数，该参数会自动剪切输入行（基本上删除换行符），然后在打印时将其追加回行的末尾。为**-e**参数指定的代码是**if length**，它表示“如果有长度则打印该行”。 空行的长度为0，因此不会打印出来（0在Perl的值是FALSE）。 所有其他行都有长度并被打印。 如果不使用**-l**，则字符串的末尾仍然会有换行符，因此长度为1或2个字符！

以下是另一种删除所有空白行的方法：

```perl
perl -ne 'print if /\S/'
```

这个单行程序的行为与前两种略有不同。**print unless /^$/** 和 **print if length**都会打印包含空格或制表符的行。这样的行看起来似乎是空白的，你可能需要过滤它们。正则表达式\S匹配非空的字符，**print if /\S/** 只打印出非空的行，删除空白行。

正如你所见，可以用许多不同的方式编写实现相同功能的程序。实际上，Perl的哲学思想是：实现目标的方法不止一种。

## 2.7 删除所以连续的空行，只留下一个

```perl
perl -00 -pe ''
```

首先它没有任何代码，**-e**是空的。接下来它有一个愚蠢的**-00**命令行选项 。此命令行选项打开 段落slurp模式。段落是两条换行符之间的文本。所有其他换行符都会被忽略。该段落放入**$_**中， **-p**选项将其打印出来。

你甚至可以用更短的方式编写此代码：

```perl
perl -00pe0
```

此处，指定给-e的代码为0，不执行任何操作。

## 2.8 将所有空白行压缩/扩展为n个连续行

假设您有一个文件，每个段落后都有两个空行，并且希望将段落之间的行距扩展为三行。你可以写成这样：

```perl
perl -00 -pe '$_ .= "\n"x2'
```

## 2.9 将所有单词之间的空格修改为双倍空格

```perl
perl -pe 's/ /  /g'
```

使用替换操作符**s**，将一个空格扩展为两个空格。

## 2.10 删除单词之间的所有间距

```perl
perl -pe 's/ +//g'
```

或者：

```perl
perl -pe 's/\s+//g'
```

## 2.11 将单词之间的所有间距更改为一个空格

```perl
perl -pe 's/\s+/ /g'
```

## 2.12 在所有字符之间插入空格

```perl
perl -lpe 's// /g'
```

或者插入其他的字符，比如：

```perl
perl -lpe 's//:/g'
```

